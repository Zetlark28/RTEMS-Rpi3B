\documentclass[12pt, a4paper, titlepage, oneside]{book}
\usepackage[utf8]{inputenc}
\usepackage[italian]{babel} %set language = italian
\usepackage{pdfpages} %include function for pdf
\usepackage{mathptmx} %set font type = times 
\textheight24cm\topmargin0mm\headheight0mm\headsep6mm\oddsidemargin20pt\evensidemargin30pt %margin 
\linespread{1.2} %interlinea
\pagestyle{plain}
\usepackage[backend=biber,style=numeric,sorting=none]{biblatex} %bibliography
\usepackage{csquotes}
\addbibresource{bibliography.bib}

\usepackage{titlesec} %style chapter
\titleformat{\chapter}
  {\normalfont\LARGE\bfseries}{\thechapter}{1em}{}
\titlespacing*{\chapter}{0pt}{3.5ex plus 1ex minus .2ex}{2.3ex plus .2ex}

\usepackage{graphicx} %insert image
\graphicspath{ {./images/} }
\usepackage{wrapfig} %for wrap figures
\usepackage{graphicx} %for size figures
\usepackage{subcaption} %for position figures

\usepackage{listings} %for code format


\begin{document}
\includepdf[pages={1}]{Frontespizio_Ezpeleta.pdf}
\tableofcontents
\setcounter{page}{0}
\begin{flushleft}
\chapter*{Introduzione}
\setcounter{page}{1}

\addcontentsline{toc}{chapter}{Introduzione} 
Il lavoro che ho svolto ha due obiettivi principali: il 'porting' di RTEMS su Raspberry Pi e la creazione di applicativi RTEMS per validare il corretto funzionamento delle interfacce GPIO, UART, I2C, SPI  e l'utilizzo degli interrupts tramite le API di RTEMS.\\
%Lo scopo del mio lavoro consiste nel 'porting' di RTEMS su Raspberry Pi e nella creazione di applicativi RTEMS  per testare il funzionamento delle interfacce GPIO, UART, I2C, SPI e l'utilizzo degli interrupts.

Per poter svolgere il 'porting' ho fatto riferimento al RTEMS User Manual\cite{rtemsUM}, per comprendere meglio i concetti di RSB(RTEMS Source Builder) e BSP (board support packages), 
ed ho utilizzato la guida fornita da ing. Basile \cite{giorgio}, di BIS-Italia, che raccoglie tutti i passaggi esposti sul blog di Alan Tech per il 'porting' della versione 4.11.\\
%ed ho utilizzato la guida fornita da AlanC trovata sul suo blog \cite{alanT} in cui viene descritto il porting per la versione 4.11.\\
%Purtroppo la guida non è totalmente corretta, poiché datata a Marzo 2013 ed è stata scritta per la versione di RTEMS precedente a quella che ho utilizzato, cioè la 5.1 che è la più recente e stabile. \\
Purtroppo i passaggi illustrati sul blog non sono totalmente corretti, poiché sono per il 'porting' della versione di RTEMS precedente a quella che ho utilizzato, cioè la 5.1 che è la più recente e stabile.
Il 'porting' puo' essere definito corretto, se alla fine della procedura si riesce a caricare uno degli applicativi di test forniti da RTEMS, su Raspberry Pi senza errori.
Dopo aver effettuato correttamente il 'porting', ho creato una guida in italiano  che raggruppa tutti i passaggi effettuati integrando le correzioni necessarie, ed è stata corretta anche la guida di ing. Basile \cite{giorgio5}.\\
Dopo aver impostato l'ambiente di lavoro ho iniziato a creare gli applicativi RTEMS da eseguire sulla Raspberry Pi.\\
Per poter creare gli applicativi RTEMS ho dovuto  familiarizzare con il linguaggio C, leggere l'RTEMS Classic API Guide \cite{rtemsCAG} ed analizzare i codici sorgente di esempio trovati nel git repository di asuol\cite{asuol} per poter comprendere l'utilizzo delle API. \\
Tutto il lavoro è stato eseguito in modalità "smart-working", per questo motivo mi è stata messa a disposizione da BIS-Italia la scheda Raspberry Pi 3B+ per poter effettuare l'attività.Microchip Technologies ha gentilmente offerto dei componenti aggiuntivi utili per gli applicativi RTEMS di test dell'interfaccia I2C e SPI.\\
Oltre all'attività software ho dovuto eseguire una piccola attività hardware, cioè creare dei circuiti saldando i vari componenti e utilizzando la breadboard in modo da poterli collegare alla Raspberry Pi, per fare ciò ho seguito gli schemi elettrici che mi ha inviato ing. Bernardini e ho letto i datasheet dei componenti dell'interfaccia I2C \cite{microchipMCP3425} \cite{microchipADC} e  SPI \cite{microchipMCP4822} \cite{microchipMSOP10-8} in modo da comprendere il loro funzionamento e poter creare i driver.\\

Premesso tutto ciò ho suddiviso la mia relazione nei seguenti capitoli:

\begin{itemize}
    \item \textbf{Capitolo 1} - in questo capitolo vengono descritte le principali tecnologie utilizzate durante il mio lavoro. Innanzitutto viene descritto RTEMS che è il sistema operativo su cui si basa tutta l'attività, dopodiché viene  descritta la Raspberry Pi su cui verranno eseguiti gli applicativi RTEMS, ed infine viene descritto Eclipse che è l'IDE utilizzato per creare gli applicativi.
    \item \textbf{Capitolo 2} - in questo capitolo viene descritta tutta l'attività di 'porting' e la definizione della toolchain per poter realizzare applicativi RTEMS. Vengono esposte tutte le problematiche rilevate e le loro soluzioni. 
    \item \textbf{Capitolo 3} - in questo capitolo vengono descritti le API che RTEMS ha a disposizione, la loro struttura e in che modo li ho testati e per quali motivi si è scelto di testarli.
    \item \textbf{Capitolo 4} - in questo capitolo viene descritta l'attività software che si basa sulla creazione degli applicativi RTEMS per testare il corretto funzionamento delle API di RTEMS. Viene esposto anche una descrizione dei componenti aggiuntivi offerti da Microchip di cui ho creato i driver per poterli utilizzare con RTEMS.
    \item \textbf{Capitolo 5} - in questo capitolo viene descritto ciò che si è raggiunto e la possibile estensione del mio lavoro.
\end{itemize} 
\chapter{Tecnologie}

\section{RTEMS}
\begin{figure}[h]
    \centering
    \includegraphics[scale = 2]{rtemslogo.png}
\end{figure}
RTEMS sta per Real-Time Executive MultiProcessor System ed è un sistema operativo real-time (RTOS) general purpose open source (licenza GPL 2.0 modificata) progettato e gestito da OAR Corporation. Il suo sviluppo iniziò nella fine degli anni 80 utilizzando i linguaggi Ada e C, e venne usato inizialmente per scopi militari, invece le prime versioni utilizzabili sono state rese open-souce su server ftp nel 1994.\\
Attualmente viene utilizzato in molti settori tra cui quello aerospaziale, infatti è stato utilizzato in alcune missioni spaziali sia a livello di on-board computer che come computer embedded in altre attività di volo
%ad esempio sul MRO (Mars Reconnaissance Orbiter) è in esecuzione un applicativo RTEMS che controlla l' Electra UHT Transceiver (EUT) che serve per la comunicazione tra Marte e la Terra . \\
RTEMS è  stato validato dall'ESA, European Space Agency, ciò vuol dire che sono stati scritti dei programmi che riproducono gli scenari critici (ad esempio la gestione di molti dispositivi oppure la gestione e l'esecuzione concorrente dei task), e sono stati eseguiti sul sistema operativo per poter verificare il suo corretto funzionamento in quei casi. La validazione viene tutt'ora aggiornata poiché è un sistema operativo che è in continua evoluzione e avrà più funzionalità con il passare del tempo.\\
RTEMS non è un sistema operativo a sé stante, usato per caricare altri programmi, ma è un executive che viene compilato con l'applicazione in un unico codice monolitico da eseguire.

\newpage
RTEMS può essere visto come un insieme di direttive raggruppate in una serie di manager, che si occupano di varie funzionalità tra cui il controllo e la sincronizzazione dei task e processori, la gestione della memoria e la mutua esclusione. Invece la gestione dello scheduling, dispatching e object management sono forniti dal executive core.
\begin{figure} [h]
    \centering
    \includegraphics[scale = 0.80]{rtems_internal_architecture.JPG}
    \caption{Architettura RTEMS}
    \label{fig:my_label1}
\end{figure}

Utilizzando i managers di RTEMS lo sviluppatore può concentrarsi al solo sviluppo del applicativo e ciò riduce notevolmente il tempo di sviluppo.\\

La figura successiva mostra la logica di utilizzo di RTEMS.
\begin{figure}[ht]
    \centering
    \includegraphics[scale = 0.80]{application_architecture.JPG}
    \caption{Struttura applicativo RTEMS}
    \label{fig:my_label2}
\end{figure}

Come si può notare RTEMS Executive è un intermediario tra il codice dell'applicativo e il target hardware, invece le dipendenze hardware con altri device sono localizzati nel livello "device drivers".
Il RTEMS I/O manager incorpora queste dipendenze hardware nel sistema mentre allo stesso momento fornisce all'application code l'accesso ad esse.
Queste dipendenze hardware sono isolate in specifiche BSP, Board Support Packages, per questo motivo il 'porting' di un applicativo RTMES su altri processori è semplice poiché basterebbe selezionare la BSP del microprocessore su cui si vuol eseguire l'applicativo e compilare con le sue librerie.\\
In questo modo durante lo sviluppo di un applicativo real-time si ha la totale indipendenza dall'architettura dei microprocessori. \\

E' disponibile il 'porting' di RTEMS su molte architetture CPU tra cui ARM, MIPS, LEON,ERC32 e i PowerPC; durante il mio lavoro ho trattato il 'porting' su architettura ARM utilizzando una Raspberry Pi 3B+.
\section{Raspberry Pi}
\begin{figure}[h]
    \centering
    \includegraphics[scale = 0.70]{raspberrypiLogo.png}
\end{figure}
Raspberry Pi è una serie di computer a scheda singola sviluppata da Raspberry Pi Foundation in collaborazione con la Broadcom, in Inghilterra.\\
Originariamente è stato usato per insegnare le basi dell'informatica nelle scuole e nei paesi in via di sviluppo, ma attualmente grazie al suo basso prezzo viene usato anche nel settore della robotica, domotica e in molti altri.
Al momento sono state rilasciate quattro generazioni di Raspberry Pi, e tutti i modelli hanno un Broadcom SoC (System on Chip) con processore ARM integrato e on-chip GPU (Graphics Processing Unit).\\
Durante il mio lavoro viene usata la \textbf{Raspberry Pi 3B+} che utilizza il Broadcom BCM2837B0 SoC \cite{bcm2837} con processore Cortex-A53 (ARMv8) 64-bit 1.4Ghz.
\newpage
\begin{figure} [h]
    \centering
    \includegraphics[scale = 1.25]{RPi3B.JPG}
    \caption{Scheda Raspberry Pi 3B+}
    \label{fig:RPI3B_laver}
\end{figure}
Tra le specifiche tecniche quelle che ci interessano maggiormente sono:
\begin{itemize}
    \item SDRAM LPDDR2 da 1GB.
    \item supporto per la micro SD.
    \item accesso a 40 GPIO.
\end{itemize}

La memoria micro SD viene utilizzata per il caricamento degli eseguibili RTEMS nel seguente modo:
\begin{enumerate}
    \item viene copiato il firmware di Raspberry Pi compatibile con RTEMS nella memoria SD.
    \item bisogna cancellare i file 'kernel*.img'. 
    \item compilare i sorgenti di un applicativo RTEMS in modo da ottenere il file con estensione'.img' 
    \item copiare l'eseguibile RTEMS nella memoria SD.
    \item impostare l'eseguibile RTEMS come kernel della scheda Raspberry Pi, modificando il file 'config.txt'
\end{enumerate}
In questo modo all'accensione della Raspberry Pi, l'eseguibile è il kernel della scheda e viene eseguito automaticamente.

\newpage
La figura successiva mostra tutti i pin GPIO che Raspberry Pi 3B+ ha a disposizione:
\begin{figure}[h]
    \centering
    \includegraphics[scale = 1.50]{RPi3B_GPIO.JPG}
    \caption{Raspberry Pi 3B+ GPIO}
    \label{fig:RPi3B_GPIO}
\end{figure}

Tutti i pin configurabili hanno un output da 0v a 3v3 e come input sono 3v3 'tollerant'.

%TODO :  forse da aggiungere più descrizione GPIO

\newpage

\section{Eclipse}
Eclipse è un IDE open source rilasciato con licenza EPL (Eclipse Public License) creato da IBM usato principalmente per la programmazione in Java ma grazie a vari plugin può essere usato per altri linguaggi di programmazione come C, C++, COBOL, Python e molti altri. \\
L'ambiente di sviluppo Eclipse include l'Eclipse Java development tools per Java, e l'Eclipse CDT per C/C++. \\
Per utilizzare RTEMS gcc cross compiler su Eclipse C, bisogna installare il plugin di RTEMS e settare le variabili di ambiente.
\begin{figure} [h]
    \centering
    \includegraphics[height = 145mm, width = 160mm ]{eclipse-i2c.png}
    \caption{Schermata Eclipse del programma I2C }
    \label{fig:eclips-i2c}
\end{figure}
%TODO : aggiungere schermata con uno dei programmi che ho fatto
\chapter{Porting di RTEMS su RPi}
%Qui ci va sia l'attività di porting (download, versioni, organizzazione) fino alla prima prova, ed anche la definizione della "toolchain" per programmare in C e realizzare applicazioni RTEMS.

L'attività di 'porting' è la prima fase del lavoro e consiste in:
\begin{enumerate}
    \item Installazione dalla tool-suite sul computer host, dove vengono creati gli applicativi RTEMS.
    \item Verifica del corretto funzionamento della tool-suite, eseguendo i programmi di test su Raspberry Pi
    \item Configurazione del IDE Eclipse C, per la creazione di eseguibili RTEMS
    \item Provare a compilare e eseguire i programmi sia da terminale, e sia da Eclipse C
\end{enumerate}
Per svolgere tutta la procedura mi sono munito di un computer con sistema operativo Ubuntu, una scheda Raspberry Pi 3B+, una micro SD, e convertitore TTL USB.\\
%Tutta la procedura viene effettuata tramite comandi eseguiti su terminale.

RTEMS in sé è complesso per questo il team di RTEMS ci fornisce "l'ecosistema di RTEMS" che è una collezione di strumenti, packages, codici sorgente e documentazione, utile per definire come sviluppare, mantenere e usare RTEMS.\\
Durante il 'porting' ho utilizzato due importanti strumenti che fanno parte dell'ecosistema RTEMS, e sono :
\begin{itemize}
    \item RTEMS RSB = l'RTEMS Source Builder è tool molto utile per compilare e fare la 'build' dei moduli di RTEMS e delle BSP 
    \item BSP  raspberrypi = la Build Support Package è il codice di supporto, che contiene le librerie di RTEMS per una specifica scheda (ad esempio la BSP raspberrypi viene usata per la Raspberry Pi 3B+)
\end{itemize}
Dopo aver effettuato correttamente tutti i passaggi per il 'porting', ho creato una guida che li espone, in questo modo che qualunque utente voglia approcciarsi ad RTEMS su RPi per la prima volta riesca ad eseguirlo senza dover cercare tra le tante fonti sparse su internet.

%TODO da capire se mettere come indice la guida del porting oppure nelle conclusioni con un elenco dei "prodotti" realizzati
\chapter{Integrazione hardware e software}
%Qui ci va una descrizione delle varie interfacce disponibili in termini di drivers SW e come le abbiamo provate.
Effettuato il 'porting' sono passato all'attività software, cioè la creazione di RTEMS executive per testare il funzionamento delle RTEMS Classic API che sono le API per l'utilizzo delle interfacce. \\
\begin{figure} [h]
\centering
    \includegraphics[scale = 0.80] {RTEMS_architecture.JPG}
    \caption{Architettura dettagliata sistema RTEMS}
    \label{fig:my_label3}
\end{figure}
%TODO elenco delle interfacce e api che ci interessano
Le interfacce che ci interessano validare sono:
\begin{itemize}
    \item UART
    \item GPIO
    \item I2C
    \item SPI
\end{itemize}

%Le interfacce che ho testato sono ;
---\\
TODO\\
----\\
%Con l'attività di 'porting' si è potuto verificare il funzionamento dell'interfaccia UART, come porta per i log di sistema che verranno utilizzati durante il debug degli applicativi RTEMS.

\chapter{Attività sperimentale}
\section{Obiettivi}
%Nell'ambito dei sistemi embedded, e soprattutto nel settore spaziale, il risultato del software oltre all'esito computazionale dipende anche dal 
L'attività sperimentale consiste nella creazione di applicativi RTEMS per validare le API di RTEMS. Un API può essere considerata valida l'applicativo associato quando il comportamento del software è quello che ci aspettiamo e che venga fatto nell'arco temporale da noi definito.\\
%TODO
%  Requisiti di validazione: cosa vogliamo provare, come e perchè. Ci sono degli agganci al mondo spaziale qui.

\section{Test set-up}
%Descrizione del sistema in generale e della/e scheda/e aggiuntiva/e per fare i vari test dell'HW
Ogni programma di test creato implica un circuito elettrico differente costruito con jumper, breadboard, resistenze, condensatori, pulsanti, LED e schede aggiuntive mandate dalla Microchip su cui ho dovuto saldare cavetti e componenti per poterli utilizzare e collegare alla Raspberry Pi.\\

I componenti aggiuntivi sono :
\begin{itemize}
    \item MCP3425 SOT23-6 Evaluation Board  \cite{microchipMCP3425}: un evaluation board, con un ADC (Analog Digital Converter) MCP3425, controllato tramite protocollo I2C
    \item MSOP-10 and MSOP-8 Evaluation Board \cite{microchipMSOP10-8}: un evaluation board generica che serve per il collegamento del componente MCP4822 alla Raspberry Pi
    \item MCP4822 \cite{microchipMCP4822}: un DAC (Digital Analog Converter) controllato tramite protocollo SPI, montato sulla evaluation board sopracitata.
\end{itemize}
\newpage
Il componente \textbf{MCP3425} è un ADC da 16 bit che ha come input due tensioni $V_{IN}^+ $ e $ V_{IN}^-$ e come output una tensione pari a $V_{IN}^+ - V_{IN}^- \times PGA$.\\ 
\begin{figure}[h]
    \centering
    \includegraphics{MCP3425.JPG}
    \caption{MCP3425}
    \label{fig:MCP3425}
\end{figure}
Il componente ha la seguente configurazione predefinita:
\begin{itemize}
    \item Programmable Gain Amplifier(PGA) = 1
    \item Continuos Conversion
    \item Programmable Data Rate = 12 bit
\end{itemize}
Durante il lavoro viene utilizzata questa configurazione, ma nel caso si volesse cambiare la configurazione del componente, si può eseguire una scrittura di due byte dove il primo byte rappresenta l'indirizzo di periferica e il bit R/W (nel nostro caso è 11010000) invece il secondo contiene i bit di configurazione\\
\newpage
\begin{figure}[h]
    \centering
    \includegraphics[scale = 1]{wrtie_configuration_MCP3425.JPG}
    \caption{Diagramma temporale scrittura su MCP3425}
    \label{fig:MCP3425_wrtie_conf}
\end{figure}
La lettura del valore in uscita dal DAC deve essere eseguita nel seguente modo:
\begin{enumerate}
    \item mandare sul bus I2C l'indirizzo di periferica con R/W pari a 1
    \item lettura dei due byte
    \item conversione dei byte per avere il valore effettivo della tensione
\end{enumerate}
\newpage

Il componente \textbf{MCP4822} è un DAC da 12 bit che ha come input il dato che viene passato da codice e come output una tensione pari a $V_{OUT} = \frac{V_{ref} \times D_n}{2^n} \times G$ dove:
\begin{itemize}
    \item $V_{ref}$ = 2.048V
    \item $D_n$ = sono i bit che passo in input
    \item $n$ = è il numero dei bit, cioè 12
    \item $G$ = è il gain
\end{itemize}

\begin{figure}[h]
\begin{subfigure}{0.5\textwidth}
\includegraphics[width=0.9\linewidth, height=5cm]{images/MCP4822.JPG} 
\caption{MCP4822}
\label{fig:MCP4822}
\end{subfigure}
\begin{subfigure}{0.5\textwidth}
\includegraphics[width=0.9\linewidth, height=5cm]{images/MCP4822_pin.JPG}
\caption{MCP4822 pin}
\label{fig:MCP4822 pin}
\end{subfigure}
\end{figure}

Il componente ha due canali e la comunicazione è unidirezionale, cioè non puo' essere eseguita una lettura ma solo la scrittura mandando due byte in cui il primo è formato dai 4 bit di configurazione e 4 data bit, e il secondo è formato solo da data bit.


\newpage
\section{Test application software}
La struttura principale che tutti i programmi seguono è la seguente:
\begin{itemize}
    \item init.c = è il file sorgente contenente la funzione Init che è il punto di partenza dell'eseguibile. E' come se fosse il metodo main in Java.
    \item init.h = è un file header che contiene tutte le direttive RTEMS per configurare il sistema
    \item task\_helper.c = è il file sorgente contenente la definizione dei task, le funzioni per la manipolazione delle variabili globali, le funzioni aggiuntive 
    \item task\_helper.h = è un file header che contiene tutte le dichiarazioni delle funzioni definite in task\_helper.c che si vogliono usare in init.c, ad esempio la definizione dei task.
\end{itemize}
La configurazione del sistema viene definita tramite le direttive RTEMS, si può definire una configurazione di base che è formata dalle seguenti direttive:
\begin{itemize}
    \item CONFIGURE\_APPLICATION\_DOES\_NOT\_NEED\_CLOCK\_DRIVER : è necessario definirlo quando non si vuole utilizzare il driver del clock e del timer.
    \item CONFIGURE\_APPLICATION\_NEEDS\_CLOCK\_DRIVER : da definire quando si vuole utilizzare il driver del clock che utilizzando la funzione rtems\_clock\_tick fornisce un interrupt ogni n microsecondi.
    \item CONFIGURE\_MICROSECONDS\_PER\_TICK n  : se viene usata la direttiva " CONFIGURE\_APPLICATION\_NEEDS\_CLOCK\_DRIVER" possiamo impostare i microsecondi per ogni clock tick, altrimenti viene impostato di default 10000  microsecondi.
    \item CONFIGURE\_APPLICATION\_NEEDS\_SIMPLE\_CONSOLE\_DRIVER: imposta il Simple Console Driver, in questo modo possiamo utilizzare la funzione "printf()" per la visualizzazione dei log.
    \item CONFIGURE\_UNLIMITED\_OBJECTS : con questa direttiva non si ha limiti di oggetti rtems, e non si ha il bisogno di gestire la RAM. Ovviamene questa direttiva non deve essere usata per applicativi da mandare in produzione, ma può essere usata durante la fase di test
    \item CONFIGURE\_UNIFIED\_WORK\_AREAS : da utilizzare quando la direttiva "CONFIGURE\_UNLIMITED\_OBJECTS" è definita poiché in questo modo viene utilizzata tutta la memoria disponibile, cioè  il  RTEMS Workspace e il C programm heap saranno in un unico pool di memoria.
    \item CONFIGURE\_RTEMS\_INIT\_TASKS\_TABLE : questa direttiva è necessaria per indicare che l'applicativo parte eseguendo il task Init che ha la priorità massima (1) e non è preemptive.
    \item CONFIGURE\_INIT : direttiva necessaria per far si che la libreria \textbf{<rtems/confdefs.h>} (che deve essere inclusa nel file header) istanzi la configurazione del sistema
\end{itemize}

%Architettura del programma di prova di un po' tutto
Il primo programma di test che ho creato è quella per l'\textbf{interfaccia UART} e si tratta di un "hello world!". È stato il più semplice da creare, poiché durante il 'porting' è stato usato un programma di esempio simile per visualizzare i log di sistema. Dal codice sorgente dei programmi di esempio forniti da RTEMS, come quelli per il ticker.img,  si può ipotizzare correttamente che per far stampare un messaggio sulla console è sufficiente definire la direttiva di sistema 
\begin{lstlisting}[language = C]
#define CONFIGURE_APPLICATION_NEEDS_SIMPLE_CONSOLE_DRIVER 
\end{lstlisting} 
e usare le funzioni della libreria standard stdio.h 
\begin{lstlisting} [language = C]
printf("log"); 
fflush(stdout);
\end{lstlisting}
ed ho come risultato:
\begin{figure}[h]
    \centering
    \includegraphics[scale = 0.5]{images/hello_world_log.png}
    \caption{Hello world log}
    \label{fig:hello_world_log}
\end{figure}
\newpage
L'\textbf{interfaccia GPIO }è stata testata con tre programmi per coprire le seguenti situazioni :
\begin{enumerate}
    \item accensione e spegnimento di un led ad intervalli di 1 secondo.
    \item alla pressione di un bottone si ha l'accensione o spegnimento di un led.
    \item alla pressione di un bottone, viene avviato un task.
\end{enumerate}

Il \textbf{primo programma} sui GPIO, il file init.c ha solo il task Init, dove è presente un ciclo infinito (while(1)) per il cambio di stato del LED e le API di RTEMS per la gestione del GPIO :
\begin{itemize}
    \item rtems\_gpio\_initialize() : inizializza le API dei GPIO
    \item rtems\_status\_code rtems\_gpio\_bsp\_select\_input(uint32\_t bank,uint32\_t pin,  void *bsp\_specific) : imposta il pin come input, discorso analogo l'output.
    \item uint32\_t rtems\_gpio\_bsp\_get\_value(uint32\_t bank, uint32\_t pin) : recupera il valore del pin
    \item rtems\_status\_code rtems\_gpio\_bsp\_clear(uint32\_t bank, uint32\_t pin) : imposta il valore del pin a 0
    \item rtems\_status\_code rtems\_gpio\_bsp\_set(uint32\_t bank, uint32\_t pin) : imposta il valore del pin a 1
\end{itemize}
%Nel file header init.h per la configurazione di sistema ho impostato i microsecondi per ogni tick a 1000000 che equivale a 1 secondo per ogni tick
\newpage
Il \textbf{secondo programma} sui GPIO ha come scopo validare anche la gestione degli interrupts. 
Ho dovuto creare un circuito elettrico per generare un interrupt da pulsante e vedere la gestione tramite lo stato di un LED.\\
\begin{figure}[h]
\begin{subfigure}{0.5\textwidth}
\includegraphics[width=1.2\linewidth, height=7cm]{images/Btn_switch_led_circuit_image.JPG}
\caption{Circuito con Raspberry Pi}
\label{fig:Circuito con Raspberry Pi}
\end{subfigure}
\begin{subfigure}{0.5\textwidth}
\includegraphics[width=1.2\linewidth, height=7cm]{images/Btn_switch_led_circuit_schema.JPG}
\caption{Schema elettrico del circuito}
\label{fig:Schema elettrico del circuito}
\end{subfigure}
\end{figure}

Per la gestione degli interrupt ho utilizzato le API di RTEMS generiche:
\begin{itemize}
    \item rtems\_status\_code rtems\_gpio\_resistor\_mode(
  uint32\_t pin\_number,
   rtems\_gpio\_pull\_mode mode
) : imposta in pull-up o pull-down la resistenza del pin
    \item rtems\_status\_code rtems\_gpio\_enable\_interrupt(
  uint32\_t pin\_number,
  rtems\_gpio\_interrupt interrupt,
  rtems\_gpio\_handler\_flag flag,
  bool threaded\_handling,
  rtems\_gpio\_irq\_state (*handler) (void *arg),
  void *arg
) : abilita l'interrupt sul pin, e assegna l'handler già definito.
    \item rtems\_status\_code rtems\_gpio\_debounce\_switch(
  uint32\_t pin\_number,
  int ticks
) : imposta il tempo del debounce del pin. 
\end{itemize}
Inoltre questo programma si verifica il problema della gestione della \textbf{sezione critica}, in questo caso si presenta alla lettura e scrittura della variabile globale g\_led\_status, ed è stata risolta utilizzando gli \textbf{eventi} e un \textbf{semaforo binario}.\\
Per utilizzare i semafori è necessario aggiungere una direttiva in più "CONFIGURE\_MAXIMUM\_SEMAPHORES " impostando il numero massimo di semafori consentiti.\\

%TODO: FINIRE o sistemare
%TODO: DESCRIZIONE DEL TERZO PROGRAMMA, DESCRIVENDO LA GESTIONE DEI TASK (STATO DEL TASK) \\
\newpage
IL \textbf{terzo programma} è composto da due task:
\begin{itemize}
    \item btn\_polling : controlla la variabile di stato del pulsante, se risulta true (quindi è stato  premuto), allora viene avviato il task led\_blink
    \item led\_blink : accende o spegne 3 volte il LED con un intervallo di tempo di 1 secondo.
\end{itemize}
Il circuito è lo stesso del programma precedente.
Anche in questo programma è presente la sezione critica per la variabile di stato del pulsante.\\
Il task principale init.c cambia lo stato del task btn\_polling in start 
In questo caso bisogna modificare lo stato dei task in modo da non farli interferire tra loro.\\
\begin{figure}[h]
    \centering
    \includegraphics[scale = 0.5]{images/task_state.JPG}
    \caption{Stato dei task}
    \label{fig:Stato dei task}
\end{figure}
\newpage
L'interfaccia \textbf{I2C} è stata testata creando un programma che legge l'output del componente ADC che ,manipolandolo come indicato dal datasheet, mi da come risultato la tensione in entrata al ADC.Poiché bisogna utilizzare un componente aggiuntivo, ho dovuto creare il driver associato.\\
%int rpi_i2c_register_bus(
 % const char *bus_path,
  %uint32_t bus_clock
%);
Il driver del componente utilizza le API RTEMS per gestire l'I2C :
\begin{itemize}
    \item i2c\_dev *i2c\_dev\_alloc\_and\_init(
  size\_t size,
  const char *bus\_path,
  uint16\_t address
);
    \item int i2c\_bus\_transfer(i2c\_bus *bus, i2c\_msg *msgs, uint32\_t msg\_count);
\end{itemize}
%TODO : DESCRIZIONE PROGRAMMA I2C E DEL DRIVER\\
Per testare l'interfaccia \textbf{SPI} è stato creato un programma che legge dal MOSI l'output del componente che dovrebbe rappresentare la tensione in uscita. Anche in questo caso si è dovuto creare il driver associato \\
%TODO : DESCRIZIONE PROGRAMMA SPI E DEL DRIVER\\
\newpage
\section{Risultati finali}
%TODO\\
	%Risultati delle prove fatte, problemi riscontrati, etc.Un po' una descrizione del lavoro svolto per dimostrare che quello che è specificato nel cap 5 è stato fatto davvero. Qui aiutano anche dati presi con la strumentazione, se possibile.
I programmi sono stati creati uno alla volta, e prima di passare alla creazione del successivo, ho fatto delle prove per verificare effettivamente se il risultato fosse quello che ci aspettiamo.
L'ordine che ho seguito nel creare i programmi 
\chapter{Conclusioni}
%TODO\\
%Nel capitolo 1 ti sei dato degli obiettivi e qui devi dimostrare che li hai raggiunti.

Il lavoro svolto fa parte dei progetti di BIS-Italia, sezione italiana della British Interplanetary Society, società storica britannica di cui sono membro, che mi ha seguito durante lo stage. BIS-Italia prevede di utilizzare RTEMS su RPi per il progetto di una replica in scala 1:3 di ExoMars Rover che verrà utilizzato per divulgazione.\\
Tutto il lavoro è stato svolto con l'aiuto dei membri di BIS-Italia e la collaborazione di Microchip.
\chapter*{Ringraziamenti}
\printbibliography
\end{flushleft}

\end{document}
